import random
import sys
import os
from prettytable import PrettyTable
import curses
       
def Karte_Erstellen(höhe,breite,liste):
        Karte = { 

            } 
        for x in range(0,höhe):
            Karte[str(x+1)]=[random.choices(liste,k=breite)]
        for Zahl in Karte:
            if Zahl=='2':
                if höhe==3 and breite==3:
                    Karte[Zahl][0][1] = "X" 
            elif Zahl =='3':
                if höhe==5 and breite==5:
                    Karte[Zahl][0][2] = "X"
            elif Zahl=='4':
                if höhe==7 and breite==7:
                    Karte[Zahl][0][3] = "X"
       
        return Karte

def Karte_Ausgeben(Karte):
    if höhe==3 & breite==3:
        t = PrettyTable(['1', '2', '3'])
    elif höhe==5 & breite==5:
       t = PrettyTable(['1', '2', '3', '4', '5'])
    elif höhe==7 & breite==7:
        t = PrettyTable(['1', '2', '3', '4', '5', '6', '7'])

    for Zahl in Karte:
        t.add_row((Karte[Zahl][0]))
    print(t)



def mouse(stdscr):
    curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_BLACK)
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_RED)

    
    curses.curs_set(0)
    stdscr = curses.initscr()

    selectedRowIndex = 0
    start_y = 0
    start_x = 0

    while True:
        stdscr = curses.initscr()
        inhalt = schreiben(selectedRowIndex)

        """ die Anwendung kann die Größe des Bildschirms mithilfe der Variablen curses.LINES und
            curses.COLS ermitteln, um die Größen y und x zu ermitteln
            y - die Hoehe (Zeile) und  
            x - der Spaltenanfang """

        y = curses.LINES - 4
        x = 1
        x2 = 1
        y2 = curses.LINES - 2
        y3 = curses.LINES - 3
        x3 = 1
        y0 = curses.LINES - 1
        fusszeile = 'F1-abbrechen / Enter-X '


            # mit addstr() - kann der Text auf dem Fesnter angezeigt werden
        stdscr.addstr(y, x, '___________________________')
        stdscr.addstr(y0, x, fusszeile)

            # Kofzeile funktioniert sowie die Fusszeile
        kopfzeile = 'Buzzword Bingo - EINZELSPIELERMODUS'
        y = 0
        x = 1
        stdscr.addstr(y, x, kopfzeile)  # zeigt de Kopfzeile an

            # Position defienieren, ab welche Zeile und Spalte wird unsere Liste aufgelistet

        pos_y = 1
        pos_x = 1

        """ da wir oben und unter Zeilen besetzt haben, müssen immer 2 wenige Zeilen aufgezählt werden, damit
            die nicht mit Datei/Ordnernamen überschrieben wird und Fuss-, Kopfzeilen ihren Platz nicht verlieren """

        anzahl_zeilen = curses.LINES - 4
        breite = curses.COLS - 2

        """ refresh() - das Fenster upzudaten 
            getch() - wird auf eine Eingabe vom Benutzer gewartet, dass der Benutzer in der Lage ist
            während des Auflisten Vorgangs weitere Funktionalitäten nutzen zu können """

        inhalt.refresh(start_y, start_x, pos_y, pos_x, anzahl_zeilen, breite)
        eingabe = stdscr.getch()

        if eingabe == curses.KEY_DOWN and selectedRowIndex + 1 < len(liste):
            selectedRowIndex += 1
            if selectedRowIndex % anzahl_zeilen == 0:
                start_y += anzahl_zeilen

        elif eingabe == curses.KEY_UP and selectedRowIndex > 0:
            selectedRowIndex -= 1
            if selectedRowIndex % anzahl_zeilen > 0:
                start_y -= anzahl_zeilen

        elif eingabe in [10, 13]:
            if liste[selectedRowIndex] == '/..':
                pfad = os.path.dirname(pfad)
            else:
                pfad = os.path.join(pfad, liste[selectedRowIndex])

            # wenn der Vorgang ausgeführt ist, soll es wieder von vorne anfangen werden
            # (Beleuchtung ist ganz oben der Liste)
            selectedRowIndex = 0
        elif eingabe == curses.KEY_F2:
            quit()

def schreiben(selectedRowIndex):

    curses.update_lines_cols()
    hohe = len(liste) + 1
    breite = curses.COLS
    win = curses.newpad(hohe, breite)
    posX = 1

    """ Die Methode enumerate () fügt einem iterablen Objekt einen Zähler hinzu und 
    gibt ihn in Form eines Aufzählungsobjekts zurück. Dieses Aufzählungsobjekt wird dann direkt 
    in der for-Schleife verwendet und mithilfe der liste() in eine Liste von Tupeln konvertiert """

    for index, row in enumerate(liste):
        # hoehe wird festgelegt
        posY = index

        # wenn der Index mit dem Index von der ausgewählten Element gleich wird
        # das Attribut aus dem "Hintergrund" -Satz hinzufügen, der auf alle Schreibvorgänge
        # im aktuellen Fenster angewendet wird.

        if index == selectedRowIndex:

            # attron() macht für dieses Element (Datei oder ein Ordner in der angezeigte Liste)
            # die Hintergrundbeleuchtung mit weißer Farbe an
            # attroff() macht aus
            # nicht ausgewählte bleiben wie sie sind

            win.attron(curses.color_pair(1))
            win.addstr(posY, posX, row)
            win.attroff(curses.color_pair(1))
        else:
            win.addstr(posY, posX, row)

    # da es hier ums Darstellen der Liste und dessen Inhalt handelt, soll das ganze Fenster wiederzurückgegen

    return win

# get_path ist auch als Hilfsfunktion implementiert wurde um den Pfad des Zielordners
# beim kopieren und verschieben zu nutzen
# hier wurde so aufgebaut, dass der Benutzer gefordert wird den Pfad des gewünschten Zielorners einzugeben

    

def gezogenes_wort(Karte, liste):
    wort_ziehen = random.choice(liste)
    for Zahl in Karte:
        y = 0
        for wort in Karte[Zahl][0]:
            if wort == wort_ziehen:
                Karte[Zahl][0][y] = "X"
            y += 1
            
    return wort_ziehen     

def Prüfen(Karte,höhe,breite):

    sieg = False
    #Zunächst werden die horizontalen Gewinne nachgeprüft
    
    for Zahl in Karte:
        counter = 0   
        for x in range(0,int(höhe)):
            if Karte[Zahl][0][x]=='X':
                counter+= 1
            
        if counter is int(höhe):
            sieg = True
            return sieg
            
    #jetzt werden die vertikalen Gewinne nachgeprüft
    for x in range(0,int(höhe)):
        counter=0

        for Zahl in Karte:
            if Karte[Zahl][0][x]=='X':
                counter+=1
        if counter==int(höhe):
            sieg=True
            return sieg

    #jetzt werden die diagonalen Gewinne nachgeprüft
    for x in range (0,int(höhe)):
        y=0
        counter=0
        for Zahl in Karte:
            if Karte[Zahl][0][y]=='X':
                counter+=1
            y+=1
        if counter==int(höhe):
            sieg=True
            return sieg

    for x in range (int(höhe),-1,-1):
        y=int(höhe)-1
        counter=0
        for Zahl in Karte:
            if Karte[Zahl][0][y]=='X':
                counter+=1
            y-=1
        if counter==int(höhe):
            sieg=True
        return sieg


def restart():
    print("Spiel startet neu aufgrund von eines FehlInputs" + "\n" + "------------------------" + "\n")
    os.execv(sys.executable, ['/bin/python3'] + sys.argv) 
def restarthöhebreite():
    print("Spiel startet neu aufgrund von eines FehlInputs")
    print("Bitte geben sie nur 3 x 3, 5 x 5, 7 x 7 ein" + "\n" + "------------------------" + "\n")
    os.execv(sys.executable, ['/bin/python3'] + sys.argv) 


#Mainmethode
print(""" 
 ____                                       _   ____  _                   
|  _ \                                     | | |  _ \(_)                  
| |_) |_   _ __________      _____  _ __ __| | | |_) |_ _ __   __ _  ___  
|  _ <| | | |_  /_  /\ \ /\ / / _ \| '__/ _` | |  _ <| | '_ \ / _` |/ _ \ 
| |_) | |_| |/ / / /  \ V  V / (_) | | | (_| | | |_) | | | | | (_| | (_) |
|____/ \__,_/___/___|  \_/\_/ \___/|_|  \__,_| |____/|_|_| |_|\__, |\___/ 
                                                               __/ |      
Fuat, Duc und Niraj                                           |___/       """)   

datei = open('text.txt','r')
liste=[]
liste = datei.read().split(';')

#Fehlererkennung bei Userinput#
while True:
    try:
        höhe=int(input("\n" + "Geben sie die Höhe der Bingokarte ein:" + "\n"))
        breite=int(input('Geben sie die Breite der Bingokarte ein:' + "\n"))
        acceptable_values = list((3, 5, 7))
        if höhe and breite in acceptable_values and höhe == breite:
            break
        else:
            restarthöhebreite()
    except ValueError:
        print("\n" + "Bitte geben Sie NUR die Ziffern ein. Versuchen sie es erneut")
        print("Das Spiel wird neugestartet" + "\n")
        restart()

while True:
    try:
        modi = int(input('''Wählen sie zwischen Zwei Spiel Modi aus Tippen sie die jeweilige Zahl ein:
        
1: Einzelspieler
2: Mehrspieler''' + "\n"))

        break
        
    except ValueError:
        print("\n" + "Bitte geben Sie NUR die Ziffern 1 oder 2 ein und kein Buchstabe. Versuchen sie es erneut")
        restart() 

#################

spielfeld=[]


if modi == 1:
    einzelspieler = Karte_Erstellen(höhe,breite,liste)
    spielfeld.append(einzelspieler)
    anzahl_spieler = 1
    curses.wrapper(mouse)
    for x in range(0,anzahl_spieler):
        Karte = Karte_Ausgeben(spielfeld[x])


elif modi == 2: 

    while True:
        try:
            anzahl_spieler=int(input('Bitte geben Sie an, wie viele Personen am Bingospiel teilnehmen möchten!'+ "\n"))
            break
        except ValueError:
            print("Bitte geben Sie nur Zahlen ein.")
            restart()

    for x in range(0,int(anzahl_spieler)):
        spielfeld.append(Karte_Erstellen(höhe,breite,liste))
        
    if höhe == 3 & breite == 3:
        t = PrettyTable(['1', '2', '3'])
    elif höhe == 5 & breite == 5:
        t = PrettyTable(['1', '2', '3', '4', '5'])
    elif höhe == 7 & breite == 7:
        t = PrettyTable(['1', '2', '3', '4', '5', '6', '7'])


    for x in range(0,int(anzahl_spieler)):
        f = open("Karte"+str(x+1), 'w')#karten erzeugt
        Karte=spielfeld[x]
            
        for Zahl in Karte:

            t.add_row(Karte[Zahl][0])
        f.write(str(t))

        for Zahl in Karte:
            for Zahl in range(0,1):
                t.del_row(Zahl)
            
            f.close

        

    
    
    print('''
Das Spiel beginnt jetzt!
ES wird immer wieder aus einer Liste Wörter gezogen, und wenn diese
in deiner Bingokarte vorkommen, so werden diese durch ein X ersetzt.

    ''')

    sieg=False
    for x in range(0,int(anzahl_spieler)):
        print("\nDrücke Enter um ein neues Wort zu ziehen.\nZum Beenden, schribe bitte quit.\n")
        user_input = input()
        words_till_win = 0

        while sieg == False and user_input != "quit":
            wort_ziehen = gezogenes_wort(spielfeld[x], liste)
            words_till_win += 1
            liste.remove(wort_ziehen)
            

            print(f"\nGezogenes Wort: {wort_ziehen}.")
            print(f"Anzahl an gezogenen Wörtern: {words_till_win}.\n\n\n")
            
            user_input=input()
            if user_input=='quit':
                print('Vielen Dank fürs Mitspielen!')
                quit()


elif modi != 1 or 2:

    print("\n" + "Bitte geben Sie NUR die Ziffern 1 oder 2 ein. Versuchen sie es erneut")
    print("Das Spiel wird neugestartet" + "\n")
    restart() 


    

print('''
    Nun beginnt das Spiel!
    ES wird immer wieder aus einer Liste Wörter gezogen, und wenn diese
    in deiner Bingokarte vorkommen, so werden diese durch ein X ersetzt.

    ''')

sieg = False



